<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Mario Bros</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #5c94fc;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #gameCanvas {
            border: 4px solid #000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            background: #5c94fc;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 0 #000;
            z-index: 10;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 14px;
            text-shadow: 2px 2px 0 #000;
            text-align: center;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="ui">
        <span>SCORE: <span id="score">0</span></span>
        <span style="margin-left: 40px;">COINS: <span id="coins">0</span></span>
        <span style="margin-left: 40px;">TIME: <span id="time">400</span></span>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="controls">
        Arrow Keys: Move | Space: Jump | R: Restart
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 800;
        canvas.height = 480;
        
        // Game state
        let score = 0;
        let coins = 0;
        let gameTime = 400;
        let gameOver = false;
        let gameWon = false;
        
        // Player
        const player = {
            x: 100,
            y: 300,
            width: 16,
            height: 16,
            velocityY: 0,
            velocityX: 0,
            speed: 3,
            jumpPower: -12,
            gravity: 0.6,
            onGround: false,
            direction: 1,
            frame: 0,
            animTimer: 0,
            inPipe: false,
            pipeTimer: 0
        };
        
        // Keys
        const keys = {};
        
        // Level design
        const platforms = [
            // Ground
            {x: 0, y: 432, width: 400, height: 48, type: 'ground'},
            {x: 450, y: 432, width: 150, height: 48, type: 'ground'},
            {x: 650, y: 432, width: 400, height: 48, type: 'ground'},
            {x: 1100, y: 432, width: 300, height: 48, type: 'ground'},
            {x: 1450, y: 432, width: 550, height: 48, type: 'ground'},
            
            // Floating platforms
            {x: 300, y: 336, width: 64, height: 16, type: 'brick'},
            {x: 400, y: 272, width: 64, height: 16, type: 'brick'},
            {x: 500, y: 208, width: 64, height: 16, type: 'brick'},
            {x: 700, y: 336, width: 96, height: 16, type: 'brick'},
            {x: 900, y: 272, width: 128, height: 16, type: 'brick'},
            {x: 1200, y: 336, width: 64, height: 16, type: 'brick'},
            {x: 1300, y: 272, width: 64, height: 16, type: 'brick'},
            {x: 1500, y: 208, width: 80, height: 16, type: 'brick'},
            
            // Pipes
            {x: 600, y: 384, width: 32, height: 48, type: 'pipe', entrance: true, exit: false, targetX: 1000},
            {x: 1000, y: 368, width: 32, height: 64, type: 'pipe', entrance: false, exit: true, targetX: null}
        ];
        
        // Coins
        const coinsList = [
            {x: 332, y: 300, collected: false},
            {x: 432, y: 236, collected: false},
            {x: 532, y: 172, collected: false},
            {x: 732, y: 300, collected: false},
            {x: 764, y: 300, collected: false},
            {x: 932, y: 236, collected: false},
            {x: 964, y: 236, collected: false},
            {x: 996, y: 236, collected: false},
            {x: 1232, y: 300, collected: false},
            {x: 1332, y: 236, collected: false},
            {x: 1532, y: 172, collected: false},
            {x: 1564, y: 172, collected: false}
        ];
        
        // Enemies
        const enemies = [
            {x: 250, y: 416, width: 16, height: 16, velocityX: -1, velocityY: 0, onGround: false, type: 'goomba'},
            {x: 700, y: 416, width: 16, height: 16, velocityX: 1, velocityY: 0, onGround: false, type: 'goomba'},
            {x: 1200, y: 416, width: 16, height: 16, velocityX: -1, velocityY: 0, onGround: false, type: 'goomba'},
            {x: 1600, y: 416, width: 16, height: 16, velocityX: 1, velocityY: 0, onGround: false, type: 'goomba'}
        ];
        
        // Flag at end
        const flag = {x: 1900, y: 240, width: 16, height: 192};
        
        // Camera
        const camera = {x: 0, y: 0};
        
        // Update camera
        function updateCamera() {
            camera.x = player.x - canvas.width / 3;
            camera.x = Math.max(0, camera.x);
            camera.x = Math.min(camera.x, 2000 - canvas.width);
        }
        
        // Draw pixel perfect rectangle
        function drawRect(x, y, width, height, color) {
            ctx.fillStyle = color;
            ctx.fillRect(Math.floor(x - camera.x), Math.floor(y), width, height);
        }
        
        // Draw player
        function drawPlayer() {
            const px = Math.floor(player.x - camera.x);
            const py = Math.floor(player.y);
            
            // Hat
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(px + 5, py, 6, 2);
            ctx.fillRect(px + 3, py + 2, 10, 3);
            
            // Hair/sideburns
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(px + 3, py + 5, 2, 2);
            ctx.fillRect(px + 11, py + 5, 2, 2);
            
            // Face
            ctx.fillStyle = '#ffdbac';
            ctx.fillRect(px + 5, py + 5, 6, 5);
            
            // Eyes
            ctx.fillStyle = '#000000';
            ctx.fillRect(px + 6, py + 6, 1, 1);
            ctx.fillRect(px + 9, py + 6, 1, 1);
            
            // Mustache
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(px + 5, py + 8, 2, 2);
            ctx.fillRect(px + 9, py + 8, 2, 2);
            
            // Shirt (red)
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(px + 4, py + 10, 8, 3);
            
            // Overalls straps
            ctx.fillStyle = '#0000ff';
            ctx.fillRect(px + 5, py + 10, 2, 1);
            ctx.fillRect(px + 9, py + 10, 2, 1);
            
            // Overalls
            ctx.fillStyle = '#0000ff';
            ctx.fillRect(px + 3, py + 13, 10, 2);
            
            // Buttons
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(px + 5, py + 11, 1, 1);
            ctx.fillRect(px + 10, py + 11, 1, 1);
            
            // Legs
            ctx.fillStyle = '#0000ff';
            ctx.fillRect(px + 4, py + 15, 3, 1);
            ctx.fillRect(px + 9, py + 15, 3, 1);
            
            // Shoes
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(px + 3, py + 15, 4, 1);
            ctx.fillRect(px + 9, py + 15, 4, 1);
        }
        
        // Draw platforms
        function drawPlatforms() {
            platforms.forEach(platform => {
                const px = Math.floor(platform.x - camera.x);
                const py = Math.floor(platform.y);
                
                if (platform.type === 'ground') {
                    // Ground texture
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(px, py, platform.width, platform.height);
                    
                    // Add grass on top
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(px, py, platform.width, 8);
                } else if (platform.type === 'brick') {
                    // Brick pattern
                    for (let i = 0; i < platform.width; i += 16) {
                        for (let j = 0; j < platform.height; j += 16) {
                            ctx.fillStyle = '#d2691e';
                            ctx.fillRect(px + i, py + j, 16, 16);
                            ctx.fillStyle = '#8b4513';
                            ctx.fillRect(px + i + 1, py + j + 1, 14, 14);
                            ctx.fillStyle = '#d2691e';
                            ctx.fillRect(px + i + 2, py + j + 2, 12, 12);
                        }
                    }
                } else if (platform.type === 'pipe') {
                    // Pipe
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(px, py, platform.width, platform.height);
                    ctx.fillStyle = '#008000';
                    ctx.fillRect(px + 2, py + 2, platform.width - 4, platform.height - 2);
                    
                    // Pipe rim (top)
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(px - 2, py - 2, platform.width + 4, 4);
                    ctx.fillStyle = '#00cc00';
                    ctx.fillRect(px, py, platform.width, 2);
                    
                    // Dark pipe opening
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(px + 4, py, platform.width - 8, 8);
                    
                    // Pipe indicator if entrance
                    if (platform.entrance) {
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(px + platform.width / 2 - 2, py + 4, 4, 2);
                    }
                }
            });
        }
        
        // Draw coins
        function drawCoins() {
            coinsList.forEach(coin => {
                if (!coin.collected) {
                    const cx = Math.floor(coin.x - camera.x);
                    const cy = Math.floor(coin.y);
                    
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(cx + 2, cy, 8, 12);
                    ctx.fillRect(cx, cy + 2, 12, 8);
                    ctx.fillStyle = '#ffed4e';
                    ctx.fillRect(cx + 4, cy + 4, 4, 4);
                }
            });
        }
        
        // Draw enemies
        function drawEnemies() {
            enemies.forEach(enemy => {
                const ex = Math.floor(enemy.x - camera.x);
                const ey = Math.floor(enemy.y);
                
                // Goomba body (mushroom shape)
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(ex + 2, ey, 12, 4);
                ctx.fillRect(ex, ey + 4, 16, 8);
                
                // Darker brown for shading
                ctx.fillStyle = '#654321';
                ctx.fillRect(ex + 4, ey + 1, 8, 2);
                ctx.fillRect(ex + 2, ey + 6, 12, 4);
                
                // Eyes (angry look)
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(ex + 4, ey + 6, 3, 3);
                ctx.fillRect(ex + 9, ey + 6, 3, 3);
                
                // Pupils
                ctx.fillStyle = '#000000';
                ctx.fillRect(ex + 5, ey + 7, 2, 2);
                ctx.fillRect(ex + 10, ey + 7, 2, 2);
                
                // Eyebrows (angry)
                ctx.fillStyle = '#000000';
                ctx.fillRect(ex + 4, ey + 5, 3, 1);
                ctx.fillRect(ex + 9, ey + 5, 3, 1);
                
                // Feet
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(ex + 2, ey + 12, 5, 4);
                ctx.fillRect(ex + 9, ey + 12, 5, 4);
            });
        }
        
        // Draw flag
        function drawFlag() {
            const fx = Math.floor(flag.x - camera.x);
            const fy = Math.floor(flag.y);
            
            // Pole
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(fx, fy, 4, flag.height);
            
            // Flag
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(fx + 4, fy + 20, 20, 16);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(fx + 8, fy + 24, 8, 8);
        }
        
        // Collision detection
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        // Update player
        function updatePlayer() {
            // Handle pipe animation
            if (player.inPipe) {
                player.pipeTimer++;
                if (player.pipeTimer > 60) {
                    player.inPipe = false;
                    player.pipeTimer = 0;
                }
                return; // Don't allow movement during pipe transition
            }
            
            // Horizontal movement
            if (keys['ArrowLeft']) {
                player.velocityX = -player.speed;
                player.direction = -1;
            } else if (keys['ArrowRight']) {
                player.velocityX = player.speed;
                player.direction = 1;
            } else {
                player.velocityX = 0;
            }
            
            // Jump
            if (keys[' '] && player.onGround) {
                player.velocityY = player.jumpPower;
                player.onGround = false;
            }
            
            // Check for pipe entrance
            if (keys['ArrowDown'] && player.onGround) {
                platforms.forEach(platform => {
                    if (platform.type === 'pipe' && platform.entrance) {
                        // Check if player is standing on top of pipe
                        const onPipe = player.x + player.width > platform.x + 4 &&
                                      player.x < platform.x + platform.width - 4 &&
                                      Math.abs(player.y + player.height - platform.y) < 5;
                        
                        if (onPipe) {
                            player.inPipe = true;
                            player.pipeTimer = 0;
                            // Teleport to exit pipe
                            setTimeout(() => {
                                player.x = platform.targetX + 8;
                                player.y = platforms.find(p => p.x === platform.targetX).y - player.height - 1;
                            }, 500);
                        }
                    }
                });
            }
            
            // Apply gravity
            player.velocityY += player.gravity;
            
            // Update position
            player.x += player.velocityX;
            player.y += player.velocityY;
            
            // Platform collision
            player.onGround = false;
            
            // Check vertical collisions first
            platforms.forEach(platform => {
                const willCollide = {
                    x: player.x,
                    y: player.y,
                    width: player.width,
                    height: player.height
                };
                
                if (checkCollision(willCollide, platform)) {
                    // Top collision (landing on platform)
                    if (player.velocityY > 0) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.onGround = true;
                    }
                    // Bottom collision (hitting head)
                    else if (player.velocityY < 0) {
                        player.y = platform.y + platform.height;
                        player.velocityY = 0;
                    }
                }
            });
            
            // Check horizontal collisions separately
            const nextX = player.x + player.velocityX;
            platforms.forEach(platform => {
                const willCollide = {
                    x: nextX,
                    y: player.y,
                    width: player.width,
                    height: player.height
                };
                
                if (checkCollision(willCollide, platform)) {
                    if (player.velocityX > 0) {
                        player.x = platform.x - player.width;
                        player.velocityX = 0;
                    } else if (player.velocityX < 0) {
                        player.x = platform.x + platform.width;
                        player.velocityX = 0;
                    }
                }
            });
            
            // Coin collection
            coinsList.forEach(coin => {
                if (!coin.collected) {
                    const coinRect = {x: coin.x, y: coin.y, width: 12, height: 12};
                    if (checkCollision(player, coinRect)) {
                        coin.collected = true;
                        coins++;
                        score += 100;
                        document.getElementById('coins').textContent = coins;
                        document.getElementById('score').textContent = score;
                    }
                }
            });
            
            // Enemy collision
            enemies.forEach(enemy => {
                if (checkCollision(player, enemy)) {
                    // Jump on enemy
                    if (player.velocityY > 0 && player.y + player.height - player.velocityY <= enemy.y + 5) {
                        score += 200;
                        document.getElementById('score').textContent = score;
                        enemy.x = -100; // Remove enemy
                        player.velocityY = -8;
                    } else {
                        gameOver = true;
                    }
                }
            });
            
            // Flag collision
            if (checkCollision(player, flag)) {
                gameWon = true;
            }
            
            // Boundaries
            if (player.x < 0) player.x = 0;
            if (player.y > canvas.height) gameOver = true;
        }
        
        // Update enemies
        function updateEnemies() {
            enemies.forEach(enemy => {
                // Apply gravity to enemies
                enemy.velocityY += player.gravity;
                enemy.y += enemy.velocityY;
                
                // Check platform collisions for enemies
                enemy.onGround = false;
                platforms.forEach(platform => {
                    const enemyRect = {
                        x: enemy.x,
                        y: enemy.y,
                        width: enemy.width,
                        height: enemy.height
                    };
                    
                    if (checkCollision(enemyRect, platform)) {
                        if (enemy.velocityY > 0) {
                            enemy.y = platform.y - enemy.height;
                            enemy.velocityY = 0;
                            enemy.onGround = true;
                        }
                    }
                });
                
                // Move horizontally
                enemy.x += enemy.velocityX;
                
                // Check for walls and edges
                let hitWall = false;
                platforms.forEach(platform => {
                    const enemyRect = {
                        x: enemy.x + enemy.velocityX,
                        y: enemy.y,
                        width: enemy.width,
                        height: enemy.height
                    };
                    
                    // Check wall collision
                    if (checkCollision(enemyRect, platform)) {
                        hitWall = true;
                    }
                    
                    // Check if about to fall off edge
                    if (enemy.onGround) {
                        const aheadRect = {
                            x: enemy.x + (enemy.velocityX > 0 ? enemy.width : -2),
                            y: enemy.y + enemy.height + 2,
                            width: 2,
                            height: 2
                        };
                        
                        let groundAhead = false;
                        platforms.forEach(p => {
                            if (checkCollision(aheadRect, p)) {
                                groundAhead = true;
                            }
                        });
                        
                        if (!groundAhead) {
                            hitWall = true;
                        }
                    }
                });
                
                // Turn around if hit wall or edge
                if (hitWall) {
                    enemy.velocityX *= -1;
                }
            });
        }
        
        // Draw game
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#5c94fc';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw clouds
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(100 - camera.x * 0.5, 80, 48, 24);
            ctx.fillRect(108 - camera.x * 0.5, 72, 32, 32);
            ctx.fillRect(400 - camera.x * 0.5, 100, 48, 24);
            ctx.fillRect(408 - camera.x * 0.5, 92, 32, 32);
            ctx.fillRect(700 - camera.x * 0.5, 60, 48, 24);
            ctx.fillRect(708 - camera.x * 0.5, 52, 32, 32);
            
            drawPlatforms();
            drawCoins();
            drawEnemies();
            drawFlag();
            drawPlayer();
            
            // Game over
            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff';
                ctx.font = '48px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
                ctx.font = '24px "Courier New"';
                ctx.fillText('Press R to Restart', canvas.width / 2, canvas.height / 2 + 50);
            }
            
            // Game won
            if (gameWon) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffd700';
                ctx.font = '48px "Courier New"';
                ctx.textAlign = 'center';
                ctx.fillText('YOU WIN!', canvas.width / 2, canvas.height / 2);
                ctx.font = '24px "Courier New"';
                ctx.fillText('Score: ' + score, canvas.width / 2, canvas.height / 2 + 50);
            }
        }
        
        // Game loop
        let lastTime = Date.now();
        let timeCounter = 0;
        
        function gameLoop() {
            const now = Date.now();
            const delta = now - lastTime;
            lastTime = now;
            
            if (!gameOver && !gameWon) {
                updatePlayer();
                updateEnemies();
                updateCamera();
                
                // Update timer
                timeCounter += delta;
                if (timeCounter >= 1000) {
                    gameTime--;
                    document.getElementById('time').textContent = gameTime;
                    timeCounter = 0;
                    if (gameTime <= 0) gameOver = true;
                }
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === 'r' || e.key === 'R') {
                location.reload();
            }
            e.preventDefault();
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            e.preventDefault();
        });
        
        // Start game
        gameLoop();
    </script>
</body>
</html>
